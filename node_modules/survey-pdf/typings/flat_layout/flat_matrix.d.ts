import { IQuestion, QuestionMatrixModel, MatrixRowModel, ItemValue } from 'survey-core';
import { SurveyPDF } from '../survey';
import { DocController, IPoint, IRect } from '../doc_controller';
import { FlatQuestion } from './flat_question';
import { IPdfBrick } from '../pdf_render/pdf_brick';
import { CompositeBrick } from '../pdf_render/pdf_composite';
import { RadioItemBrick } from '../pdf_render/pdf_radioitem';
import { CheckItemBrick } from '../pdf_render/pdf_checkitem';
export declare class FlatMatrix extends FlatQuestion {
    protected survey: SurveyPDF;
    protected controller: DocController;
    static readonly GAP_BETWEEN_ROWS: number;
    protected question: QuestionMatrixModel;
    constructor(survey: SurveyPDF, question: IQuestion, controller: DocController);
    protected generateFlatsHeader(point: IPoint): Promise<IPdfBrick[]>;
    protected generateFlatsRows(point: IPoint, isVertical: boolean): Promise<IPdfBrick[]>;
    private rowTitleWidth;
    private columnWidth;
    private calculateColumnsWidthes;
    generateFlatsContent(point: IPoint): Promise<IPdfBrick[]>;
}
export declare class FlatMatrixRow {
    protected survey: SurveyPDF;
    protected question: QuestionMatrixModel;
    protected controller: DocController;
    private row;
    private rowIndex;
    private key;
    protected isFirst: boolean;
    protected isVertical: boolean;
    private rowTitleWidth;
    private columnWidth;
    private radioGroupWrap;
    constructor(survey: SurveyPDF, question: QuestionMatrixModel, controller: DocController, row: MatrixRowModel, rowIndex: number, key: string, isFirst: boolean, isVertical: boolean, rowTitleWidth: number, columnWidth: number);
    generateFlatsContent(point: IPoint): Promise<IPdfBrick[]>;
    protected generateFlatItem(rect: IRect, item: ItemValue, index: number, key: string, context?: any): CheckItemBrick | RadioItemBrick;
    protected generateTextComposite(point: IPoint, column: ItemValue, index: number): Promise<IPdfBrick>;
    protected generateItemComposite(point: IPoint, column: ItemValue, index: number): Promise<IPdfBrick>;
    protected generateFlatsHorizontallyCells(point: IPoint): Promise<(IPdfBrick | CompositeBrick)[]>;
    protected generateFlatsVerticallyCells(point: IPoint): Promise<IPdfBrick[]>;
    protected generateVerticallyItems(point: IPoint, itemValues: ItemValue[]): Promise<IPdfBrick[]>;
}
