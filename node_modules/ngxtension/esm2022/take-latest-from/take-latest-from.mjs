import { combineLatestWith, concatMap, of, take, } from 'rxjs';
/**
 * Every time the source observable emits, `takeLatestFrom()` waits
 * for the provided observables to emit a value, and when each of
 * them has emitted, `takeLatestFrom()` emits and unsubscribes
 * from the provided observables.
 *
 * Let's say we have a source observable `src$` and a provided observable `data$`.
 *
 * ```ts
 * src$.pipe(whitLatestFrom(data$)).subscribe();
 * ```
 *
 * Cases when `withLatestFrom()` will not emit when `src$` emits:
 *
 * - if `data$` is a cold observable and emitted before `src$` emitted;
 * - if `data$` emitted after `src$` emitted (`data$` can be hot or cold).
 *
 * In the first case, `withLatestFrom()` will wait for the next `data$` value to emit,
 * and `takeLatestFrom()` will do the same.
 *
 * In the second case, `withLatestFrom()` will wait for the next `src$` value to emit,
 * and `takeLatestFrom()` will emit at the moment when `data$` emits its value.
 *
 * You would use `takeLatestFrom()` when you have some observable, and every time it emits,
 * you want to attach the latest values from some other observables and handle them.
 * If these other observables don't have a value yet, you would like to wait until they emit at least one value (each).
 *
 * Example:
 *
 * ```ts
 * class ExampleStore {
 *  private readonly dataSrv = inject(DataService);
 *  private readonly userSrv = inject(UserService);
 *
 *  public readonly updateData = createEffect<DataType>((_) =>
 *    _.pipe(
 *      takeLatestFrom(() => [this.dataSrv.getData(), this.userSrv.getUser()]),
 *      exhaustMap(([newData, oldData, user]) =>
 *        this.dataSrv.updateData(merge({}, oldData, newData), user),
 *      ),
 *    ),
 *  );
 * }
 * ```
 */
export function takeLatestFrom(observablesFactory) {
    return concatMap((value) => {
        const observables = observablesFactory(value);
        const observablesAsArray = Array.isArray(observables)
            ? observables
            : [observables];
        return of(value).pipe(combineLatestWith(...observablesAsArray), take(1));
    });
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidGFrZS1sYXRlc3QtZnJvbS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL2xpYnMvbmd4dGVuc2lvbi90YWtlLWxhdGVzdC1mcm9tL3NyYy90YWtlLWxhdGVzdC1mcm9tLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFDTixpQkFBaUIsRUFDakIsU0FBUyxFQUlULEVBQUUsRUFFRixJQUFJLEdBQ0osTUFBTSxNQUFNLENBQUM7QUFTZDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7R0E0Q0c7QUFDSCxNQUFNLFVBQVUsY0FBYyxDQVM1QixrQkFBbUM7SUFDcEMsT0FBTyxTQUFTLENBQUMsQ0FBQyxLQUFLLEVBQUUsRUFBRTtRQUMxQixNQUFNLFdBQVcsR0FBRyxrQkFBa0IsQ0FBQyxLQUFLLENBQUMsQ0FBQztRQUM5QyxNQUFNLGtCQUFrQixHQUFHLEtBQUssQ0FBQyxPQUFPLENBQUMsV0FBVyxDQUFDO1lBQ3BELENBQUMsQ0FBQyxXQUFXO1lBQ2IsQ0FBQyxDQUFDLENBQUMsV0FBVyxDQUFDLENBQUM7UUFFakIsT0FBTyxFQUFFLENBQUMsS0FBSyxDQUFDLENBQUMsSUFBSSxDQUNwQixpQkFBaUIsQ0FBQyxHQUFHLGtCQUFrQixDQUFDLEVBQ3hDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FDcUIsQ0FBQztJQUMvQixDQUFDLENBQUMsQ0FBQztBQUNKLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuXHRjb21iaW5lTGF0ZXN0V2l0aCxcblx0Y29uY2F0TWFwLFxuXHR0eXBlIE9ic2VydmFibGUsXG5cdHR5cGUgT2JzZXJ2YWJsZUlucHV0LFxuXHR0eXBlIE9ic2VydmVkVmFsdWVPZixcblx0b2YsXG5cdHR5cGUgT3BlcmF0b3JGdW5jdGlvbixcblx0dGFrZSxcbn0gZnJvbSAncnhqcyc7XG5cbmV4cG9ydCBmdW5jdGlvbiB0YWtlTGF0ZXN0RnJvbTxUIGV4dGVuZHMgT2JzZXJ2YWJsZTx1bmtub3duPltdLCBWPihcblx0b2JzZXJ2YWJsZXNGYWN0b3J5OiAodmFsdWU6IFYpID0+IFsuLi5UXSxcbik6IE9wZXJhdG9yRnVuY3Rpb248ViwgW1YsIC4uLnsgW2kgaW4ga2V5b2YgVF06IE9ic2VydmVkVmFsdWVPZjxUW2ldPiB9XT47XG5leHBvcnQgZnVuY3Rpb24gdGFrZUxhdGVzdEZyb208VCBleHRlbmRzIE9ic2VydmFibGU8dW5rbm93bj4sIFY+KFxuXHRvYnNlcnZhYmxlRmFjdG9yeTogKHZhbHVlOiBWKSA9PiBULFxuKTogT3BlcmF0b3JGdW5jdGlvbjxWLCBbViwgT2JzZXJ2ZWRWYWx1ZU9mPFQ+XT47XG5cbi8qKlxuICogRXZlcnkgdGltZSB0aGUgc291cmNlIG9ic2VydmFibGUgZW1pdHMsIGB0YWtlTGF0ZXN0RnJvbSgpYCB3YWl0c1xuICogZm9yIHRoZSBwcm92aWRlZCBvYnNlcnZhYmxlcyB0byBlbWl0IGEgdmFsdWUsIGFuZCB3aGVuIGVhY2ggb2ZcbiAqIHRoZW0gaGFzIGVtaXR0ZWQsIGB0YWtlTGF0ZXN0RnJvbSgpYCBlbWl0cyBhbmQgdW5zdWJzY3JpYmVzXG4gKiBmcm9tIHRoZSBwcm92aWRlZCBvYnNlcnZhYmxlcy5cbiAqXG4gKiBMZXQncyBzYXkgd2UgaGF2ZSBhIHNvdXJjZSBvYnNlcnZhYmxlIGBzcmMkYCBhbmQgYSBwcm92aWRlZCBvYnNlcnZhYmxlIGBkYXRhJGAuXG4gKlxuICogYGBgdHNcbiAqIHNyYyQucGlwZSh3aGl0TGF0ZXN0RnJvbShkYXRhJCkpLnN1YnNjcmliZSgpO1xuICogYGBgXG4gKlxuICogQ2FzZXMgd2hlbiBgd2l0aExhdGVzdEZyb20oKWAgd2lsbCBub3QgZW1pdCB3aGVuIGBzcmMkYCBlbWl0czpcbiAqXG4gKiAtIGlmIGBkYXRhJGAgaXMgYSBjb2xkIG9ic2VydmFibGUgYW5kIGVtaXR0ZWQgYmVmb3JlIGBzcmMkYCBlbWl0dGVkO1xuICogLSBpZiBgZGF0YSRgIGVtaXR0ZWQgYWZ0ZXIgYHNyYyRgIGVtaXR0ZWQgKGBkYXRhJGAgY2FuIGJlIGhvdCBvciBjb2xkKS5cbiAqXG4gKiBJbiB0aGUgZmlyc3QgY2FzZSwgYHdpdGhMYXRlc3RGcm9tKClgIHdpbGwgd2FpdCBmb3IgdGhlIG5leHQgYGRhdGEkYCB2YWx1ZSB0byBlbWl0LFxuICogYW5kIGB0YWtlTGF0ZXN0RnJvbSgpYCB3aWxsIGRvIHRoZSBzYW1lLlxuICpcbiAqIEluIHRoZSBzZWNvbmQgY2FzZSwgYHdpdGhMYXRlc3RGcm9tKClgIHdpbGwgd2FpdCBmb3IgdGhlIG5leHQgYHNyYyRgIHZhbHVlIHRvIGVtaXQsXG4gKiBhbmQgYHRha2VMYXRlc3RGcm9tKClgIHdpbGwgZW1pdCBhdCB0aGUgbW9tZW50IHdoZW4gYGRhdGEkYCBlbWl0cyBpdHMgdmFsdWUuXG4gKlxuICogWW91IHdvdWxkIHVzZSBgdGFrZUxhdGVzdEZyb20oKWAgd2hlbiB5b3UgaGF2ZSBzb21lIG9ic2VydmFibGUsIGFuZCBldmVyeSB0aW1lIGl0IGVtaXRzLFxuICogeW91IHdhbnQgdG8gYXR0YWNoIHRoZSBsYXRlc3QgdmFsdWVzIGZyb20gc29tZSBvdGhlciBvYnNlcnZhYmxlcyBhbmQgaGFuZGxlIHRoZW0uXG4gKiBJZiB0aGVzZSBvdGhlciBvYnNlcnZhYmxlcyBkb24ndCBoYXZlIGEgdmFsdWUgeWV0LCB5b3Ugd291bGQgbGlrZSB0byB3YWl0IHVudGlsIHRoZXkgZW1pdCBhdCBsZWFzdCBvbmUgdmFsdWUgKGVhY2gpLlxuICpcbiAqIEV4YW1wbGU6XG4gKlxuICogYGBgdHNcbiAqIGNsYXNzIEV4YW1wbGVTdG9yZSB7XG4gKiAgcHJpdmF0ZSByZWFkb25seSBkYXRhU3J2ID0gaW5qZWN0KERhdGFTZXJ2aWNlKTtcbiAqICBwcml2YXRlIHJlYWRvbmx5IHVzZXJTcnYgPSBpbmplY3QoVXNlclNlcnZpY2UpO1xuICpcbiAqICBwdWJsaWMgcmVhZG9ubHkgdXBkYXRlRGF0YSA9IGNyZWF0ZUVmZmVjdDxEYXRhVHlwZT4oKF8pID0+XG4gKiAgICBfLnBpcGUoXG4gKiAgICAgIHRha2VMYXRlc3RGcm9tKCgpID0+IFt0aGlzLmRhdGFTcnYuZ2V0RGF0YSgpLCB0aGlzLnVzZXJTcnYuZ2V0VXNlcigpXSksXG4gKiAgICAgIGV4aGF1c3RNYXAoKFtuZXdEYXRhLCBvbGREYXRhLCB1c2VyXSkgPT5cbiAqICAgICAgICB0aGlzLmRhdGFTcnYudXBkYXRlRGF0YShtZXJnZSh7fSwgb2xkRGF0YSwgbmV3RGF0YSksIHVzZXIpLFxuICogICAgICApLFxuICogICAgKSxcbiAqICApO1xuICogfVxuICogYGBgXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0YWtlTGF0ZXN0RnJvbTxcblx0VCBleHRlbmRzIE9ic2VydmFibGVJbnB1dDx1bmtub3duPltdIHwgT2JzZXJ2YWJsZUlucHV0PHVua25vd24+LFxuXHRWLFxuXHRSID0gW1xuXHRcdFYsXG5cdFx0Li4uKFQgZXh0ZW5kcyBPYnNlcnZhYmxlSW5wdXQ8dW5rbm93bj5bXVxuXHRcdFx0PyB7IFtpIGluIGtleW9mIFRdOiBPYnNlcnZlZFZhbHVlT2Y8VFtpXT4gfVxuXHRcdFx0OiBbT2JzZXJ2ZWRWYWx1ZU9mPFQ+XSksXG5cdF0sXG4+KG9ic2VydmFibGVzRmFjdG9yeTogKHZhbHVlOiBWKSA9PiBUKTogT3BlcmF0b3JGdW5jdGlvbjxWLCBSPiB7XG5cdHJldHVybiBjb25jYXRNYXAoKHZhbHVlKSA9PiB7XG5cdFx0Y29uc3Qgb2JzZXJ2YWJsZXMgPSBvYnNlcnZhYmxlc0ZhY3RvcnkodmFsdWUpO1xuXHRcdGNvbnN0IG9ic2VydmFibGVzQXNBcnJheSA9IEFycmF5LmlzQXJyYXkob2JzZXJ2YWJsZXMpXG5cdFx0XHQ/IG9ic2VydmFibGVzXG5cdFx0XHQ6IFtvYnNlcnZhYmxlc107XG5cblx0XHRyZXR1cm4gb2YodmFsdWUpLnBpcGUoXG5cdFx0XHRjb21iaW5lTGF0ZXN0V2l0aCguLi5vYnNlcnZhYmxlc0FzQXJyYXkpLFxuXHRcdFx0dGFrZSgxKSxcblx0XHQpIGFzIHVua25vd24gYXMgT2JzZXJ2YWJsZTxSPjtcblx0fSk7XG59XG4iXX0=