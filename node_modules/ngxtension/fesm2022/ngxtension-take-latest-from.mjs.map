{"version":3,"file":"ngxtension-take-latest-from.mjs","sources":["../../../../libs/ngxtension/take-latest-from/src/take-latest-from.ts","../../../../libs/ngxtension/take-latest-from/src/ngxtension-take-latest-from.ts"],"sourcesContent":["import {\n\tcombineLatestWith,\n\tconcatMap,\n\ttype Observable,\n\ttype ObservableInput,\n\ttype ObservedValueOf,\n\tof,\n\ttype OperatorFunction,\n\ttake,\n} from 'rxjs';\n\nexport function takeLatestFrom<T extends Observable<unknown>[], V>(\n\tobservablesFactory: (value: V) => [...T],\n): OperatorFunction<V, [V, ...{ [i in keyof T]: ObservedValueOf<T[i]> }]>;\nexport function takeLatestFrom<T extends Observable<unknown>, V>(\n\tobservableFactory: (value: V) => T,\n): OperatorFunction<V, [V, ObservedValueOf<T>]>;\n\n/**\n * Every time the source observable emits, `takeLatestFrom()` waits\n * for the provided observables to emit a value, and when each of\n * them has emitted, `takeLatestFrom()` emits and unsubscribes\n * from the provided observables.\n *\n * Let's say we have a source observable `src$` and a provided observable `data$`.\n *\n * ```ts\n * src$.pipe(whitLatestFrom(data$)).subscribe();\n * ```\n *\n * Cases when `withLatestFrom()` will not emit when `src$` emits:\n *\n * - if `data$` is a cold observable and emitted before `src$` emitted;\n * - if `data$` emitted after `src$` emitted (`data$` can be hot or cold).\n *\n * In the first case, `withLatestFrom()` will wait for the next `data$` value to emit,\n * and `takeLatestFrom()` will do the same.\n *\n * In the second case, `withLatestFrom()` will wait for the next `src$` value to emit,\n * and `takeLatestFrom()` will emit at the moment when `data$` emits its value.\n *\n * You would use `takeLatestFrom()` when you have some observable, and every time it emits,\n * you want to attach the latest values from some other observables and handle them.\n * If these other observables don't have a value yet, you would like to wait until they emit at least one value (each).\n *\n * Example:\n *\n * ```ts\n * class ExampleStore {\n *  private readonly dataSrv = inject(DataService);\n *  private readonly userSrv = inject(UserService);\n *\n *  public readonly updateData = createEffect<DataType>((_) =>\n *    _.pipe(\n *      takeLatestFrom(() => [this.dataSrv.getData(), this.userSrv.getUser()]),\n *      exhaustMap(([newData, oldData, user]) =>\n *        this.dataSrv.updateData(merge({}, oldData, newData), user),\n *      ),\n *    ),\n *  );\n * }\n * ```\n */\nexport function takeLatestFrom<\n\tT extends ObservableInput<unknown>[] | ObservableInput<unknown>,\n\tV,\n\tR = [\n\t\tV,\n\t\t...(T extends ObservableInput<unknown>[]\n\t\t\t? { [i in keyof T]: ObservedValueOf<T[i]> }\n\t\t\t: [ObservedValueOf<T>]),\n\t],\n>(observablesFactory: (value: V) => T): OperatorFunction<V, R> {\n\treturn concatMap((value) => {\n\t\tconst observables = observablesFactory(value);\n\t\tconst observablesAsArray = Array.isArray(observables)\n\t\t\t? observables\n\t\t\t: [observables];\n\n\t\treturn of(value).pipe(\n\t\t\tcombineLatestWith(...observablesAsArray),\n\t\t\ttake(1),\n\t\t) as unknown as Observable<R>;\n\t});\n}\n","/**\n * Generated bundle index. Do not edit.\n */\n\nexport * from './index';\n"],"names":[],"mappings":";;AAkBA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA4CG;AACG,SAAU,cAAc,CAS5B,kBAAmC,EAAA;AACpC,IAAA,OAAO,SAAS,CAAC,CAAC,KAAK,KAAI;AAC1B,QAAA,MAAM,WAAW,GAAG,kBAAkB,CAAC,KAAK,CAAC,CAAC;AAC9C,QAAA,MAAM,kBAAkB,GAAG,KAAK,CAAC,OAAO,CAAC,WAAW,CAAC;AACpD,cAAE,WAAW;AACb,cAAE,CAAC,WAAW,CAAC,CAAC;AAEjB,QAAA,OAAO,EAAE,CAAC,KAAK,CAAC,CAAC,IAAI,CACpB,iBAAiB,CAAC,GAAG,kBAAkB,CAAC,EACxC,IAAI,CAAC,CAAC,CAAC,CACqB,CAAC;AAC/B,KAAC,CAAC,CAAC;AACJ;;ACpFA;;AAEG;;;;"}