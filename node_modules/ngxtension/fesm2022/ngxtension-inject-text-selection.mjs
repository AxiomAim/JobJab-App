import { DOCUMENT } from '@angular/common';
import * as i0 from '@angular/core';
import { inject, signal, computed, Injectable, DestroyRef } from '@angular/core';
import { explicitEffect } from 'ngxtension/explicit-effect';

class TextSelectionService {
    constructor() {
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        this.window = inject(DOCUMENT).defaultView;
        // A writable signal to store number of listeners
        this.listeners = signal(0);
        // A writable signal to store the current Selection (or null).
        this.selection = signal(null);
        // A computed signal that returns the current selected text.
        this.text = computed(() => this.selection() ? this.selection()?.toString() : '');
        // A computed signal that returns the list of Range objects (if any).
        this.ranges = computed(() => 
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        this.selection() ? getRangesFromSelection(this.selection()) : []);
        // A computed signal that maps each Range to its bounding client rect.
        this.rects = computed(() => this.ranges().map((range) => range.getBoundingClientRect()));
        this.isListening = false;
        /**
         * Handler for the 'selectionchange' event.
         * We first clear the signal, then update it with the latest selection.
         */
        const onSelectionChange = () => {
            this.selection.set(null);
            if (this.window) {
                this.selection.set(this.window.getSelection());
            }
        };
        explicitEffect([this.listeners], ([listeners]) => {
            if (listeners === 0 && this.isListening) {
                // if we don't have any listeners anymore, we need to remove the event listener
                this.window.document.removeEventListener('selectionchange', onSelectionChange);
                this.isListening = false;
            }
            if (listeners > 0 && !this.isListening) {
                this.window.document.addEventListener('selectionchange', onSelectionChange, {
                    passive: true,
                });
                this.isListening = true;
            }
        });
    }
    /**
     * Clears the selection. This is a convenience method for `window.getSelection().empty()`.
     */
    resetSelection() {
        this.window.getSelection()?.empty();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.7", ngImport: i0, type: TextSelectionService, deps: [], target: i0.ɵɵFactoryTarget.Injectable }); }
    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "18.2.7", ngImport: i0, type: TextSelectionService, providedIn: 'root' }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.7", ngImport: i0, type: TextSelectionService, decorators: [{
            type: Injectable,
            args: [{ providedIn: 'root' }]
        }], ctorParameters: () => [] });
/**
 * Returns an array of Range objects from a Selection.
 */
function getRangesFromSelection(selection) {
    const rangeCount = selection.rangeCount ?? 0;
    return Array.from({ length: rangeCount }, (_, i) => selection.getRangeAt(i));
}
/**
 * Creates reactive signals for text selection.
 *
 * Example:
 * ```ts
 * const selection = injectTextSelection();
 *
 * selection.text() // returns the selected text
 * selection.rects() // returns an array of bounding rects for each selection range
 * selection.ranges() // returns an array of Range objects for each selection range
 * selection.selection() // returns the Selection object
 * selection.clearSelection() // clears the selection
 * ```
 *
 * @returns An object with signals for the selected text, selection ranges, rects, and the raw selection.
 */
function injectTextSelection() {
    const textSelectionService = inject(TextSelectionService);
    const destroyRef = inject(DestroyRef);
    // we want to increase the listeners count when the component is created and decrease it when it is destroyed
    // this is to ensure that we only add the event listener when there are listeners
    textSelectionService.listeners.update((x) => x + 1);
    destroyRef.onDestroy(() => textSelectionService.listeners.update((x) => x - 1));
    return {
        text: textSelectionService.text,
        rects: textSelectionService.rects,
        ranges: textSelectionService.ranges,
        selection: textSelectionService.selection.asReadonly(),
        clearSelection: () => textSelectionService.resetSelection(),
    };
}

/**
 * Generated bundle index. Do not edit.
 */

export { TextSelectionService, injectTextSelection };
//# sourceMappingURL=ngxtension-inject-text-selection.mjs.map
