{"version":3,"file":"ngxtension-inject-query-params.mjs","sources":["../../../../libs/ngxtension/inject-query-params/src/inject-query-params.ts","../../../../libs/ngxtension/inject-query-params/src/ngxtension-inject-query-params.ts"],"sourcesContent":["import { inject, type Signal } from '@angular/core';\nimport { toSignal } from '@angular/core/rxjs-interop';\nimport { ActivatedRoute, type Params } from '@angular/router';\nimport { assertInjector } from 'ngxtension/assert-injector';\nimport {\n\tDefaultValueOptions,\n\tInjectorOptions,\n\tParseOptions,\n} from 'ngxtension/shared';\nimport { map } from 'rxjs';\n\ntype QueryParamsTransformFn<ReadT> = (params: Params) => ReadT;\n\n/**\n * The `QueryParamsOptions` type defines options for configuring the behavior of the `injectQueryParams` function.\n *\n * @template ReadT - The expected type of the read value.\n * @template WriteT - The type of the value to be written.\n * @template DefaultValueT - The type of the default value.\n */\nexport type QueryParamsOptions<ReadT, DefaultValueT> = ParseOptions<\n\tReadT,\n\tstring | null\n> &\n\tDefaultValueOptions<DefaultValueT> &\n\tInjectorOptions & {\n\t\t/**\n\t\t * The initial value to use if the query parameter is not present or undefined.\n\t\t *\n\t\t * @deprecated Use `defaultValue` as a replacement.\n\t\t */\n\t\tinitialValue?: DefaultValueT;\n\t\t/**\n\t\t * A transformation function to convert the written value to the expected read value.\n\t\t *\n\t\t * @deprecated Use `parse` as a replacement.\n\t\t * @param v - The value to transform.\n\t\t * @returns The transformed value.\n\t\t */\n\t\ttransform?: (v: string | null) => ReadT;\n\t};\n\n/**\n * The `injectQueryParams` function allows you to access and manipulate query parameters from the current route.\n *\n * @returns A `Signal` that emits the entire query parameters object.\n */\nexport function injectQueryParams(): Signal<Params>;\n\n/**\n * The `injectQueryParams` function allows you to access and manipulate query parameters from the current route.\n *\n * @param {string} key - The name of the query parameter to retrieve.\n * @returns {Signal} A `Signal` that emits the value of the specified query parameter, or `null` if it's not present.\n */\nexport function injectQueryParams(key: string): Signal<string | null>;\n\n/**\n * The `injectQueryParams` function allows you to access and manipulate query parameters from the current route.\n *\n * @param {string} key - The name of the query parameter to retrieve.\n * @param {QueryParamsOptions} options - Optional configuration options for the query parameter.\n * @returns {Signal} A `Signal` that emits the transformed value of the specified query parameter, or `null` if it's not present.\n */\nexport function injectQueryParams<ReadT>(\n\tkey?: string,\n\toptions?: QueryParamsOptions<ReadT, ReadT>,\n): Signal<ReadT | null>;\n\n/**\n * The `injectQueryParams` function allows you to access and manipulate query parameters from the current route.\n * It retrieves the value of a query parameter based on a custom transform function applied to the query parameters object.\n *\n * @template ReadT - The expected type of the read value.\n * @param {QueryParamsTransformFn<ReadT>} fn - A transform function that takes the query parameters object (`params: Params`) and returns the desired value.\n * @returns {Signal} A `Signal` that emits the transformed value based on the provided custom transform function.\n *\n * @example\n * const searchValue = injectQueryParams((params) => params['search'] as string);\n */\nexport function injectQueryParams<ReadT>(\n\tfn: QueryParamsTransformFn<ReadT>,\n): Signal<ReadT>;\n\n/**\n * The `injectQueryParams` function allows you to access and manipulate query parameters from the current route.\n *\n * @template ReadT - The expected type of the read value.\n * @param {string} keyOrParamsTransform - The name of the query parameter to retrieve, or a parse function to apply to the query parameters object.\n * @param {QueryParamsOptions} options - Optional configuration options for the query parameter.\n * @returns {Signal} A `Signal` that emits the parsed value of the specified query parameter, or the entire query parameters object if no key is provided.\n *\n * @example\n * const search = injectQueryParams('search'); // returns the value of the 'search' query param\n * const search = injectQueryParams(p => p['search'] as string); // same as above but can be used with a custom parse function\n * const idParam = injectQueryParams('id', {parse: numberAttribute}); // returns the value fo the 'id' query params and parses it into a number\n * const idParam = injectQueryParams(p => numberAttribute(p['id'])); // same as above but can be used with a custom transform function\n * const queryParams = injectQueryParams(); // returns the entire query params object\n */\nexport function injectQueryParams<ReadT>(\n\tkeyOrParamsTransform?: string | ((params: Params) => ReadT),\n\toptions: QueryParamsOptions<ReadT, ReadT> = {},\n): Signal<ReadT | Params | string | boolean | number | null> {\n\treturn assertInjector(injectQueryParams, options?.injector, () => {\n\t\tconst route = inject(ActivatedRoute);\n\t\tconst queryParams = route.snapshot.queryParams || {};\n\n\t\tconst { parse, transform, initialValue, defaultValue } = options;\n\n\t\tif (!keyOrParamsTransform) {\n\t\t\treturn toSignal(route.queryParams, { initialValue: queryParams });\n\t\t}\n\n\t\tif (typeof keyOrParamsTransform === 'function') {\n\t\t\treturn toSignal(route.queryParams.pipe(map(keyOrParamsTransform)), {\n\t\t\t\tinitialValue: keyOrParamsTransform(queryParams),\n\t\t\t});\n\t\t}\n\n\t\tconst getParam = (params: Params) => {\n\t\t\tconst param = params?.[keyOrParamsTransform] as\n\t\t\t\t| string\n\t\t\t\t| string[]\n\t\t\t\t| undefined;\n\n\t\t\tif (!param) {\n\t\t\t\treturn defaultValue ?? initialValue ?? null;\n\t\t\t}\n\n\t\t\tif (Array.isArray(param)) {\n\t\t\t\tif (param.length < 1) {\n\t\t\t\t\treturn defaultValue ?? initialValue ?? null;\n\t\t\t\t}\n\t\t\t\treturn parse\n\t\t\t\t\t? parse(param[0])\n\t\t\t\t\t: transform\n\t\t\t\t\t\t? transform(param[0])\n\t\t\t\t\t\t: param[0];\n\t\t\t}\n\n\t\t\treturn parse ? parse(param) : transform ? transform(param) : param;\n\t\t};\n\n\t\treturn toSignal(route.queryParams.pipe(map(getParam)), {\n\t\t\tinitialValue: getParam(queryParams),\n\t\t});\n\t});\n}\n\n/**\n * The `injectQueryParams` function namespace provides additional functionality for handling array query parameters.\n */\nexport namespace injectQueryParams {\n\t/**\n\t * Retrieve an array query parameter with optional configuration options.\n\t *\n\t * @param {string} key - The name of the array query parameter to retrieve.\n\t * @param {QueryParamsOptions} options - Optional configuration options for the array query parameter.\n\t * @returns {Signal} A `Signal` that emits an array of values for the specified query parameter, or `null` if it's not present.\n\t */\n\texport function array(\n\t\tkey: string,\n\t\toptions?: QueryParamsOptions<string, string[]>,\n\t): Signal<string[] | null>;\n\n\t/**\n\t * Retrieve an array query parameter with optional configuration options.\n\t *\n\t * @param {string} key - The name of the array query parameter to retrieve.\n\t * @param {QueryParamsOptions} options - Optional configuration options for the array query parameter.\n\t * @returns {Signal} A `Signal` that emits an array of values for the specified query parameter, or `null` if it's not present.\n\t */\n\texport function array<ReadT>(\n\t\tkey: string,\n\t\toptions?: QueryParamsOptions<ReadT, ReadT[]>,\n\t): Signal<ReadT[] | null>;\n\n\t/**\n\t * Retrieve an array query parameter with optional configuration options.\n\t *\n\t * @template ReadT - The expected type of the read value.\n\t * @param {string} key - The name of the array query parameter to retrieve.\n\t * @param {QueryParamsOptions} options - Optional configuration options for the array query parameter.\n\t * @returns {Signal} A `Signal` that emits an array of transformed values for the specified query parameter, or `null` if it's not present.\n\t */\n\texport function array<ReadT>(\n\t\tkey: string,\n\t\toptions: QueryParamsOptions<ReadT, ReadT[]> = {},\n\t): Signal<(ReadT | string)[] | null> {\n\t\treturn assertInjector(injectQueryParams.array, options?.injector, () => {\n\t\t\tconst route = inject(ActivatedRoute);\n\t\t\tconst queryParams = route.snapshot.queryParams || {};\n\n\t\t\tconst { parse, transform, initialValue, defaultValue } = options;\n\n\t\t\tconst transformParam = (\n\t\t\t\tparam: string | string[] | null,\n\t\t\t): (ReadT | string)[] | null => {\n\t\t\t\tif (!param) {\n\t\t\t\t\treturn defaultValue ?? initialValue ?? null;\n\t\t\t\t}\n\t\t\t\tif (Array.isArray(param)) {\n\t\t\t\t\tif (param.length < 1) {\n\t\t\t\t\t\treturn defaultValue ?? initialValue ?? null;\n\t\t\t\t\t}\n\t\t\t\t\t// Avoid passing the parse function directly into the map function,\n\t\t\t\t\t// because parse may inadvertently use the array index as its second argument.\n\t\t\t\t\t// Typically, map provides the array index as the second argument to its callback,\n\t\t\t\t\t// which can conflict with parse functions like numberAttribute that expect a fallbackValue as their second parameter.\n\t\t\t\t\t// This mismatch can lead to unexpected behavior, such as values being erroneously converted to array indices\n\t\t\t\t\t// instead of NaN (which would be correct)\n\t\t\t\t\treturn parse\n\t\t\t\t\t\t? param.map((it) => parse(it))\n\t\t\t\t\t\t: transform\n\t\t\t\t\t\t\t? param.map((it) => transform(it))\n\t\t\t\t\t\t\t: param;\n\t\t\t\t}\n\t\t\t\treturn [parse ? parse(param) : transform ? transform(param) : param];\n\t\t\t};\n\n\t\t\tconst getParam = (params: Params) => {\n\t\t\t\tconst param = params?.[key];\n\n\t\t\t\treturn transformParam(param);\n\t\t\t};\n\n\t\t\treturn toSignal(route.queryParams.pipe(map(getParam)), {\n\t\t\t\tinitialValue: getParam(queryParams),\n\t\t\t});\n\t\t});\n\t}\n}\n","/**\n * Generated bundle index. Do not edit.\n */\n\nexport * from './index';\n"],"names":[],"mappings":"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"}