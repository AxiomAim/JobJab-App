{"version":3,"file":"ngxtension-inject-route-fragment.mjs","sources":["../../../../libs/ngxtension/inject-route-fragment/src/inject-route-fragment.ts","../../../../libs/ngxtension/inject-route-fragment/src/ngxtension-inject-route-fragment.ts"],"sourcesContent":["import { inject, type Signal } from '@angular/core';\nimport { toSignal } from '@angular/core/rxjs-interop';\nimport { ActivatedRoute } from '@angular/router';\nimport { assertInjector } from 'ngxtension/assert-injector';\nimport {\n\tDefaultValueOptions,\n\tInjectorOptions,\n\tParseOptions,\n} from 'ngxtension/shared';\nimport { map } from 'rxjs';\n\n/**\n * The `InjectRouteFragmentOptions` type defines options for configuring the behavior of the `injectRouteFragment` function.\n *\n * @template T - The expected type of the read value.\n */\nexport type InjectRouteFragmentOptions<T = unknown> = ParseOptions<\n\tT,\n\tstring | null\n> &\n\tInjectorOptions &\n\tDefaultValueOptions<T> & {\n\t\t/**\n\t\t * A transformation function to convert the written value to the expected read value.\n\t\t *\n\t\t * @deprecated Use `parse` as a replacement.\n\t\t * @param v - The value to transform.\n\t\t * @returns The transformed value.\n\t\t */\n\t\ttransform?: (v: string | null) => T;\n\t};\n\n/**\n * The `injectRouteFragment` function allows you to access and transform url fragment from the current route.\n *\n * @returns {Signal} A `Signal` that emits the route fragment.\n */\nexport function injectRouteFragment(): Signal<string | null>;\n\n/**\n * The `injectRouteFragment` function allows you to access and transform url fragment from the current route.\n *\n * @param {InjectRouteFragmentOptions} options - inject options like transform fn.\n * @returns {Signal} A `Signal` that emits the transformed value of url fragment.\n */\nexport function injectRouteFragment<T>(\n\toptions: InjectRouteFragmentOptions<T>,\n): Signal<T>;\n\nexport function injectRouteFragment<T>(\n\toptions?: InjectRouteFragmentOptions<T>,\n) {\n\treturn assertInjector(injectRouteFragment, options?.injector, () => {\n\t\tconst route = inject(ActivatedRoute);\n\t\tconst initialRouteFragment = route.snapshot.fragment;\n\t\tconst getFragment = (fragment: string | null) => {\n\t\t\tif (fragment === null && options?.defaultValue) {\n\t\t\t\treturn options.defaultValue;\n\t\t\t}\n\t\t\tif (options?.parse) {\n\t\t\t\treturn options.parse(fragment);\n\t\t\t}\n\t\t\tif (options?.transform) {\n\t\t\t\treturn options.transform(fragment);\n\t\t\t}\n\n\t\t\treturn fragment;\n\t\t};\n\t\tconst fragment$ = route.fragment.pipe(map(getFragment));\n\n\t\treturn toSignal(fragment$, {\n\t\t\tinitialValue: getFragment(initialRouteFragment),\n\t\t});\n\t});\n}\n","/**\n * Generated bundle index. Do not edit.\n */\n\nexport * from './index';\n"],"names":[],"mappings":";;;;;;AAiDM,SAAU,mBAAmB,CAClC,OAAuC,EAAA;IAEvC,OAAO,cAAc,CAAC,mBAAmB,EAAE,OAAO,EAAE,QAAQ,EAAE,MAAK;AAClE,QAAA,MAAM,KAAK,GAAG,MAAM,CAAC,cAAc,CAAC,CAAC;AACrC,QAAA,MAAM,oBAAoB,GAAG,KAAK,CAAC,QAAQ,CAAC,QAAQ,CAAC;AACrD,QAAA,MAAM,WAAW,GAAG,CAAC,QAAuB,KAAI;YAC/C,IAAI,QAAQ,KAAK,IAAI,IAAI,OAAO,EAAE,YAAY,EAAE;gBAC/C,OAAO,OAAO,CAAC,YAAY,CAAC;aAC5B;AACD,YAAA,IAAI,OAAO,EAAE,KAAK,EAAE;AACnB,gBAAA,OAAO,OAAO,CAAC,KAAK,CAAC,QAAQ,CAAC,CAAC;aAC/B;AACD,YAAA,IAAI,OAAO,EAAE,SAAS,EAAE;AACvB,gBAAA,OAAO,OAAO,CAAC,SAAS,CAAC,QAAQ,CAAC,CAAC;aACnC;AAED,YAAA,OAAO,QAAQ,CAAC;AACjB,SAAC,CAAC;AACF,QAAA,MAAM,SAAS,GAAG,KAAK,CAAC,QAAQ,CAAC,IAAI,CAAC,GAAG,CAAC,WAAW,CAAC,CAAC,CAAC;QAExD,OAAO,QAAQ,CAAC,SAAS,EAAE;AAC1B,YAAA,YAAY,EAAE,WAAW,CAAC,oBAAoB,CAAC;AAC/C,SAAA,CAAC,CAAC;AACJ,KAAC,CAAC,CAAC;AACJ;;AC1EA;;AAEG;;;;"}