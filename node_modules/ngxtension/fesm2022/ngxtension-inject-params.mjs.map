{"version":3,"file":"ngxtension-inject-params.mjs","sources":["../../../../libs/ngxtension/inject-params/src/inject-params.ts","../../../../libs/ngxtension/inject-params/src/ngxtension-inject-params.ts"],"sourcesContent":["import { inject, type Signal } from '@angular/core';\nimport { toSignal } from '@angular/core/rxjs-interop';\nimport { ActivatedRoute, type Params } from '@angular/router';\nimport { assertInjector } from 'ngxtension/assert-injector';\nimport {\n\tDefaultValueOptions,\n\tInjectorOptions,\n\tParseOptions,\n} from 'ngxtension/shared';\nimport { map } from 'rxjs';\n\ntype ParamsTransformFn<ReadT> = (params: Params) => ReadT;\n\n/**\n * The `ParamsOptions` type defines options for configuring the behavior of the `injectParams` function.\n *\n * @template ReadT - The expected type of the read value.\n * @template WriteT - The type of the value to be written.\n * @template DefaultValueT - The type of the default value.\n */\nexport type ParamsOptions<ReadT, WriteT, DefaultValueT> = ParseOptions<\n\tReadT,\n\tWriteT\n> &\n\tDefaultValueOptions<DefaultValueT> &\n\tInjectorOptions;\n\n/**\n * The `injectParams` function allows you to access and manipulate parameters from the current route.\n *\n * @returns A `Signal` that emits the entire parameters object.\n */\nexport function injectParams(): Signal<Params>;\n\n/**\n * The `injectParams` function allows you to access and manipulate parameters from the current route.\n *\n * @param {string} key - The name of the parameter to retrieve.\n * @returns {Signal} A `Signal` that emits the value of the specified parameter, or `null` if it's not present.\n */\nexport function injectParams(key: string): Signal<string | null>;\n\n/**\n * The `injectParams` function allows you to access and manipulate parameters from the current route.\n *\n * @param {string} key - The name of the parameter to retrieve.\n * @param {ParamsOptions} options - Optional configuration options for the parameter.\n * @returns {Signal} A `Signal` that emits the transformed value of the specified parameter, or `null` if it's not present.\n */\nexport function injectParams<ReadT>(\n\tkey?: string,\n\toptions?: ParamsOptions<ReadT, string, ReadT>,\n): Signal<ReadT | null>;\n\n/**\n * The `injectParams` function allows you to access and manipulate parameters from the current route.\n * It retrieves the value of a parameter based on a custom transform function applied to the parameters object.\n *\n * @template ReadT - The expected type of the read value.\n * @param {ParamsTransformFn<ReadT>} fn - A transform function that takes the parameters object (`params: Params`) and returns the desired value.\n * @returns {Signal} A `Signal` that emits the transformed value based on the provided custom transform function.\n *\n * @example\n * const searchValue = injectParams((params) => params['search'] as string);\n */\nexport function injectParams<ReadT>(\n\tfn: ParamsTransformFn<ReadT>,\n): Signal<ReadT>;\n\n/**\n * Injects the params from the current route.\n * If a key is provided, it will return the value of that key.\n * If a transform function is provided, it will return the result of that function.\n * Otherwise, it will return the entire params object.\n *\n * @template T - The expected type of the read value.\n * @param keyOrParamsTransform OPTIONAL The key of the param to return, or a transform function to apply to the params object\n * @param {ParamsOptions} options - Optional configuration options for the parameter.\n * @returns {Signal} A `Signal` that emits the transformed value of the specified parameter, or the entire parameters object if no key is provided.\n *\n * @example\n * const userId = injectParams('id'); // returns the value of the 'id' param\n * const userId = injectParams(p => p['id'] as string); // same as above but can be used with a custom transform function\n * const params = injectParams(); // returns the entire params object\n *\n */\nexport function injectParams<T>(\n\tkeyOrParamsTransform?: string | ((params: Params) => T),\n\toptions: ParamsOptions<T, string, T> = {},\n): Signal<T | Params | string | null> {\n\treturn assertInjector(injectParams, options?.injector, () => {\n\t\tconst route = inject(ActivatedRoute);\n\t\tconst params = route.snapshot.params;\n\t\tconst { parse, defaultValue } = options;\n\n\t\tif (!keyOrParamsTransform) {\n\t\t\treturn toSignal(route.params, { initialValue: params });\n\t\t}\n\n\t\tif (typeof keyOrParamsTransform === 'function') {\n\t\t\treturn toSignal(route.params.pipe(map(keyOrParamsTransform)), {\n\t\t\t\tinitialValue: keyOrParamsTransform(params),\n\t\t\t});\n\t\t}\n\n\t\tconst getParam = (params: Params) => {\n\t\t\tconst param = params?.[keyOrParamsTransform] as string | undefined;\n\n\t\t\tif (!param) {\n\t\t\t\treturn defaultValue ?? null;\n\t\t\t}\n\n\t\t\treturn parse ? parse(param) : param;\n\t\t};\n\n\t\treturn toSignal(route.params.pipe(map(getParam)), {\n\t\t\tinitialValue: getParam(params),\n\t\t});\n\t});\n}\n","/**\n * Generated bundle index. Do not edit.\n */\n\nexport * from './index';\n"],"names":[],"mappings":";;;;;;AAqEA;;;;;;;;;;;;;;;;AAgBG;SACa,YAAY,CAC3B,oBAAuD,EACvD,UAAuC,EAAE,EAAA;IAEzC,OAAO,cAAc,CAAC,YAAY,EAAE,OAAO,EAAE,QAAQ,EAAE,MAAK;AAC3D,QAAA,MAAM,KAAK,GAAG,MAAM,CAAC,cAAc,CAAC,CAAC;AACrC,QAAA,MAAM,MAAM,GAAG,KAAK,CAAC,QAAQ,CAAC,MAAM,CAAC;AACrC,QAAA,MAAM,EAAE,KAAK,EAAE,YAAY,EAAE,GAAG,OAAO,CAAC;QAExC,IAAI,CAAC,oBAAoB,EAAE;AAC1B,YAAA,OAAO,QAAQ,CAAC,KAAK,CAAC,MAAM,EAAE,EAAE,YAAY,EAAE,MAAM,EAAE,CAAC,CAAC;SACxD;AAED,QAAA,IAAI,OAAO,oBAAoB,KAAK,UAAU,EAAE;AAC/C,YAAA,OAAO,QAAQ,CAAC,KAAK,CAAC,MAAM,CAAC,IAAI,CAAC,GAAG,CAAC,oBAAoB,CAAC,CAAC,EAAE;AAC7D,gBAAA,YAAY,EAAE,oBAAoB,CAAC,MAAM,CAAC;AAC1C,aAAA,CAAC,CAAC;SACH;AAED,QAAA,MAAM,QAAQ,GAAG,CAAC,MAAc,KAAI;AACnC,YAAA,MAAM,KAAK,GAAG,MAAM,GAAG,oBAAoB,CAAuB,CAAC;YAEnE,IAAI,CAAC,KAAK,EAAE;gBACX,OAAO,YAAY,IAAI,IAAI,CAAC;aAC5B;AAED,YAAA,OAAO,KAAK,GAAG,KAAK,CAAC,KAAK,CAAC,GAAG,KAAK,CAAC;AACrC,SAAC,CAAC;AAEF,QAAA,OAAO,QAAQ,CAAC,KAAK,CAAC,MAAM,CAAC,IAAI,CAAC,GAAG,CAAC,QAAQ,CAAC,CAAC,EAAE;AACjD,YAAA,YAAY,EAAE,QAAQ,CAAC,MAAM,CAAC;AAC9B,SAAA,CAAC,CAAC;AACJ,KAAC,CAAC,CAAC;AACJ;;ACvHA;;AAEG;;;;"}